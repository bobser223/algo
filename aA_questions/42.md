Алгоритм Дейкстри. Аналіз алгоритму.

---
Як і алгоритм Беллмана – Форда, __алгоритм
Дейкстри__ дозволяє знайти найкоротший
шлях від однієї фіксованої вершини графа
до всіх інших його вершин, проте є значно
оптимальнішим.

Суттєвим обмеженням цього алгоритму у
порівнянні з алгоритмом Беллмана – Форда
є те, що він працює лише для графів, не
містять ребер від’ємної ваги

Задіємо додаткову інформацію для всіх вершин графа, а саме навантаження, що
визначає величину найкоротшого шляху від стартової вершини до поточної
вершини графа.

Вважається, що відстань від стартової точки до себе є нульовою, а відстані до всіх
інших точок графу є нескінченними.

---

Алгоритмічна складність залежить від того, як реалізований граф та яким чином здійснюється вибір вершини з навантаженням найкоротшого шляху.

Вибір вершини здійснюється послідовним перебором.

Нехай n – кількість вершин у графі, m – кількість ребер у графі (m ≤ n(n – 1)).

У випадку реалізації графа через матрицю суміжності алгоритмічна складність буде O(n²) у найгіршому випадку.

У випадку реалізації графа через список суміжності алгоритмічна складність буде O(n²) у найгіршому випадку.


Алгоритмічна складність залежить від того, як реалізований граф та яким чином здійснюється вибір вершини з навантаженням найкоротшого шляху.

Вибір вершини здійснюється пріоритетною чергою на базі двійкової купи.

Нехай n – кількість вершин у графі, m – кількість ребер у графі (m ≤ n(n − 1)).

У випадку реалізації графа через матрицю суміжності алгоритмічна складність буде O(n² + mlog n) у найгіршому випадку.

У випадку реалізації графа через список суміжності алгоритмічна складність буде O((n + m) log n) у найгіршому випадку.


---



```c++

#include <queue>


using namespace std;


struct edge{
	int to;
	int weight;

	bool operator<(edge& other){
		return this->weight < other.weight;
	}
};


void dejikstra(int start){
	priority_queue<edge> pq;

	vector<bool> visited(size+1, false);
    
    const static int INF = 100500;

    vector<int> distances(size+1, INF);
    distances[start] = 0;

    pq.push({start, 0});

    while(!pq.empty()){

        auto [curr, curr_w] = pq.top();pq.pop();
        
        
        
        if(distances[curr] < curr_w) continue;


		visited[curr] = true;


        for(auto [nei, nei_w] : lst[curr]){
            if(visited[nei]) continue;

            if (distances[nei] > distances[curr] + nei_w){
                distances[nei] = distances[curr] + nei_w;
                pq.push({nei, distances[curr] + nei_w});
            }
        }

    }
}

```

