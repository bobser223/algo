Дійсний бінарний пошук. Підходи для моменту завершення пошуку. Їх переваги та недоліки в порівнянні один з одним. Реалізація та аналіз алгоритму.

---
Задано функцію $f \in [a, b]$, що неспадна або незростаюча на області визначення та задане дійсне число c, __дійсний бінарний пошук__ розвяже задачу $f(x) = c$ на $[a, b]$ (знайде найменше таке x)

---
1) точність по аргументу: $r-l < \varepsilon$ 
2) точність по значенню: $|f(m)-c| < \varepsilon$
3) безпосереднє сусідство 2-х дійсних чисел `while(m != l && m != r)`
---
1) Беремо будь яке число з інтервалу $[l, r]$, проблема коли функція швидко зростає
2) Беремо m, проблеми коли функція повільно зростає (та іноді коли швидко зростає, програма зациклюється бо `m == l` або`m == r` [в числі типу даб скінченна кількість можливих значень])
3) Майже ідеальний 
---

```c++
double f(double var) {return var}

double binary_continious(double a, double b, double c){
	double l = a;
	double r = b;
	double m = (l+r) / 2.0;
	while(l!=m && r!= m){
		if (f(m) < c){
			l = m;
		} else {
			r = m;
		}
		m = (l+r) /2.0
	}
	return l;

}
```
