

__Алгоритм Беллмана – Форда__ – це _ітеративний алгоритм_, що не лише дозволяє
знайти найкоротший шлях від однієї вершини до іншої у зваженому графі, але й
знайти _найкоротші шляхи від однієї вершини зваженого графа до усіх інших_ його
вершин.

Його перевагою над іншими
алгоритмами є те, що він може
відшукати найкоротший шлях у графі,
що _містить ребра від’ємної ваги_, якщо
граф не має циклів від’ємної ваги. Крім
цього, алгоритм Беллмана – Форда
дозволяє досить просто визначити чи
містить граф цикл від’ємної ваги.

## Визначення додаткового навантаження

- Для кожної вершини **\(v\)** встановлюється **додаткове навантаження** \(d(v)\) — величина найкоротшого шляху від стартової вершини **\(s\)** до поточної вершини **\(v\)**.
- На початку роботи алгоритму приймаємо:
  $$
  d(v) = \infty, \quad \forall v
  $$


Алгоритмічна складність залежить від того, **як реалізований граф**.

Нехай $n$ – кількість вершин у графі, $m$ – кількість ребер у графі  
$$(m \leq n(n - 1))$$.

---

- У випадку реалізації графа через **матрицю суміжності**, алгоритмічна складність буде  
  $$
  O(n^3)
  $$  
  у найгіршому випадку.

- У випадку реалізації графу через **список суміжності**, алгоритмічна складність буде  
  $$
  O(n^2 + nm)
  $$  
  у найгіршому випадку.

## Implementation

```c++
std::vector<int> belman_ford(int start){  
        int n = g_size;  
  
        std::vector<int> distances(g_size, INF);  
        distances[start] = 0;  
  
        for (int iter = 0; iter < n-1; iter++){  
            for (int v = 0; v < g_size; v++){  
                for(auto [neighbour, weight]: graph[v]){  
                    if (distances[v] + weight < distances[neighbour])  
                        distances[neighbour] = distances[v] + weight;  
                }            }        }  
        return distances;  
    }  
```
