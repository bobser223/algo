По факту це [[algorithms and data structures/graphs/algorithms/BFS|BFS]], але замість звичайної черги використовується пріоритетна

Як і **алгоритм Беллмана – Форда**, **алгоритм Дейкстри** дозволяє знайти найкоротший шлях від однієї фіксованої вершини графа до всіх інших його вершин, проте є **значно оптимальнішим**.

---

Суттєвим обмеженням цього алгоритму у порівнянні з алгоритмом Беллмана – Форда є те, що **він працює лише для графів, які не містять ребер від’ємної ваги**.

---

Задіємо **додаткову інформацію** для всіх вершин графа, а саме — **навантаження**, що визначає **величину найкоротшого шляху від стартової вершини до поточної вершини графа**.

---

Вважається, що:
- Відстань від стартової точки **до себе** є **нульовою**.
- Відстані до **всіх інших точок графу** — **нескінченні**.
## Capacity
Алгоритмічна складність залежить від того, **як реалізований граф** та **яким чином здійснюється вибір вершини** з навантаженням найкоротшого шляху.

Вибір вершини здійснюється **послідовним перебором**.

Нехай $n$ – кількість вершин у графі, $m$ – кількість ребер у графі $$(m \leq n(n - 1))$$.

---

- У випадку реалізації графа через **матрицю суміжності**, алгоритмічна складність буде  
  $$
  O(n^2)
  $$  
  у найгіршому випадку.

- У випадку реалізації графу через **список суміжності**, алгоритмічна складність буде  
  $$
  O(n^2)
  $$  
  у найгіршому випадку.

Алгоритмічна складність залежить від того, **як реалізований граф** та **яким чином здійснюється вибір вершини** з навантаженням найкоротшого шляху.

Вибір вершини здійснюється **пріоритетною чергою** на базі **двійкової купи**.

Нехай $n$ – кількість вершин у графі, $m$ – кількість ребер у графі $$(m \leq n(n - 1))$$.

---

- У випадку реалізації графа через **матрицю суміжності**, алгоритмічна складність буде  
  $$
  O(n^2 + m \log n)
  $$  
  у найгіршому випадку.

- У випадку реалізації графу через **список суміжності**, алгоритмічна складність буде  
  $$
  O((n + m) \log n)
  $$  
  у найгіршому випадку.


## Implementation

```c++
std::vector<int> dijkstra(int start){  
    std::vector<int> distances(g_size, INF);  
    distances[start] = 0;  
  
  
    priority_queue<edge> pq;  
    pq.emplace(start, 0);  
  
  
    while (!pq.empty()){  
        auto [curr, curr_w] = pq.top(); pq.pop();  
  
        // Якщо це запис застарів — пропускаємо  
        if (curr_w > distances[curr])  
            continue;  
  
  
  
        for (auto [neighbour, nei_w]: graph[curr]){  
  
            if (curr_w + nei_w < distances[neighbour]){  
                distances[neighbour] = curr_w + nei_w;  
                pq.emplace(neighbour, curr_w + nei_w);  
            }        }    }  
    return distances;  
  
  
}
```

