### brackets
Нам потрібно зрозуміти чи коректно стоять дужки в даному виразі 

#### Idea

1) зустрівши відкриту дужку будемо її запам’ятовувати (вштовхуючи у стек) – це потенційний початок дужкового контейнера.

2) щойно зустрічається закрита дужка, намагаємося дістати зі стеку відкриту дужку:

-  якщо це можливо, це означає, що знайдено дужковий контейнер і він вилучається з розгляду;

-  якщо це не можливо (стек порожній), то вихідний вираз утворює не правильну дужкову послідовність, що і завершує аналіз.

3) після того, як усі дужки опрацьовані (і, відповідно, вилучено всі правильні контейнери), аналізуємо чи стек порожній:

4) якщо так, то вихідний вираз утворює правильну дужкову послідовність,

5) якщо ні, то вихідний вираз утворює не правильну дужкову послідовність.
#### implementation
```python
def bracketsChecker(brackets_sequence):
	""" Перевіряє чи brackets_sequence правильна дужкова послідовність
	:param brackets_sequence: дужкова послідовність
	:return: True, якщо brackets_sequence - правильна дужкова послідовність
	"""
	s = Stack() # Створюємо порожній стек
	for bracket in brackets_sequence:
		if bracket == "(":
			s.push(bracket) # Потенційний початок контейнера
		else:
			if s.empty():
				return False # Дужкова послідовність не правильна
			else:
				s.pop() # Прибираємо контейнер з розгляду
	return s.empty()
```

більш важкий приклад, де дужки 3-х типів
[leetcode 20](https://leetcode.com/problems/valid-parentheses/description/)
```c++
  
  

template <typename T>

void printStack(std::stack<T> stack) {

  

while (!stack.empty()) {

std::cout << stack.top() << " ";

stack.pop();

}

std::cout << std::endl;

}

  
  

class Solution {

public:

	static bool isValid(std::string s) {
	
		std::stack<char> st;
		
		for (char ch: s){
			
			if (ch == '(' || ch == '{' || ch == '['){
			
				st.push(ch);
			
			} else {
			
				if (st.empty()) return false;
				
				  
				
				if (ch == ')' && st.top() == '('){
					st.pop();
					continue;
				}
				
				
				if (ch == '}' && st.top() == '{') {
					st.pop();
					continue;
				}
				
				if (ch == ']' && st.top() == '['){
					st.pop();
					continue;
				}
				return false;
			
			}
			
			// printStack(st);
			
			  
			
			}
		
		if (!st.empty()) return false;
		
		return true;
	
	  
	
	}

};
```

### Форма запису виразу
Припустимо інфіксний вираз є рядком токенів розділених символами пропуску.

"25 * ( 3 + 5 )"

Токенами операторів є символи

'+', '-', '*', '/',

що відповідають операторам додавання, віднімання, множення та
ділення, а також круглі дужки

'(', ')'

Токеном операнда є рядок, що містить число

#### Інфіксний -> постфіксний

1) Перетворюємо інфіксний рядок у список токенів

2) Створюємо порожній стек для зберігання операторів та дужок.

3) Створюємо порожній вихідний список для виразу у постфіксній нотації.

4) Скануємо список токенів зліва направо.

- Якщо токен є операндом, то додаємо його у кінець вихідного списку.

- Якщо токен ліва дужка, кладемо її у стек.

- Якщо токен права дужка, виштовхуємо елементи зі стеку операторів, поки не буде знайдено відповідна ліва дужка. При цьому кожен оператор додається у кінець вихідного списку.

- Якщо токен є оператором, то вштовхуємо його в стек операторів. При цьому аналізуємо оператор, що у верхівці стеку: якщо він має вищий або такий же пріоритет, то виштовхуємо його і додаємо до вихідного списку.

5) Після завершення сканування вхідного списку, перевіряємо стек – всі оператори, що містяться у ньому слід виштовхнути зі стеку і додати у кінець вихідного списку.


---
##### implementation
```python
import re

def tokenize(expression):
    """
    Функція розбиває інфіксний рядок на список токенів (числа, оператори, дужки).
    """
    # Цей регулярний вираз знаходить десяткові та цілі числа, а також оператори і дужки.
    token_pattern = r'\d+\.\d+|\d+|[+*/^-()]'
    tokens = re.findall(token_pattern, expression)
    return tokens

def infix_to_postfix(expression):
    """
    Перетворює інфіксний вираз у постфіксний.
    """
    # Отримуємо список токенів
    tokens = tokenize(expression)
    
    # Стек для операторів та список для вихідного постфіксного виразу
    operator_stack = []
    output = []
    
    # Визначаємо пріоритет операторів (чим більше число, тим вищий пріоритет)
    precedence = {
        '+': 1,
        '-': 1,
        '*': 2,
        '/': 2,
        '^': 3  # Зауважте: для оператора ^ (піднесення до степеня) часто використовується права асоціативність
    }
    
    # Скануємо токени зліва направо
    for token in tokens:
        # Якщо токен є операндом (число), додаємо його до вихідного списку
        if re.match(r'\d+(\.\d+)?', token):
            output.append(token)
        # Якщо токен – ліва дужка, кладемо її у стек
        elif token == '(':
            operator_stack.append(token)
        # Якщо токен – права дужка, виштовхуємо зі стеку до зустрічі лівої дужки
        elif token == ')':
            while operator_stack and operator_stack[-1] != '(':
                output.append(operator_stack.pop())
            if operator_stack:
                operator_stack.pop()  # видаляємо ліву дужку
            else:
                raise ValueError("Невірне розташування дужок")
        # Якщо токен є оператором
        else:
            # Виштовхуємо оператори з верхівки стеку, якщо вони мають вищий або такий же пріоритет
            while (operator_stack and operator_stack[-1] != '(' and 
                   precedence.get(operator_stack[-1], 0) >= precedence.get(token, 0)):
                output.append(operator_stack.pop())
            operator_stack.append(token)
    
    # Після завершення сканування виштовхуємо всі залишкові оператори у вихідний список
    while operator_stack:
        if operator_stack[-1] in ('(', ')'):
            raise ValueError("Невірне розташування дужок")
        output.append(operator_stack.pop())
    
    return " ".join(output)

# Приклад використання
if __name__ == "__main__":
    infix_expr = "3 + 4 * (2 - 1)"
    postfix_expr = infix_to_postfix(infix_expr)
    print("Інфіксний вираз: ", infix_expr)
    print("Постфіксний вираз: ", postfix_expr)

```

#### Інфіксний -> суфіксний

1. **Розбиття виразу на токени:**  
    Розбиваємо вхідний інфіксний рядок на список токенів (операнди, оператори, дужки).  
    _Приклад:_ `"3 + 4 * (2 - 1)"` → `["3", "+", "4", "*", "(", "2", "-", "1", ")"]`.
    
2. **Ініціалізація структуру даних:**
    
    - Створюємо порожній стек для зберігання операторів та дужок.
    - Створюємо порожній вихідний список для суфіксного запису.
3. **Обхід токенів зліва направо:**
    
    - Якщо токен є **операндом** (число або змінна), додаємо його до вихідного списку.
    - Якщо токен є **лівою дужкою** `(`, кладемо її в стек.
    - Якщо токен є **правою дужкою** `)`, виштовхуємо елементи зі стеку до тих пір, поки не знайдемо відповідну ліву дужку. Всі виштовхнуті оператори додаємо до вихідного списку, а саму ліву дужку вилучаємо.
    - Якщо токен є **оператором**, порівнюємо його пріоритет з оператором, що знаходиться на вершині стеку:
        - Якщо на вершині стеку знаходиться оператор із більшим або рівним пріоритетом, виштовхуємо його та додаємо до вихідного списку.
        - Потім кладемо поточний оператор до стеку.
4. **Завершення:**  
    Після обробки всіх токенів виштовхуємо всі залишкові оператори зі стеку у вихідний список.
    

---
##### Implementation
```python
import re

def tokenize(expression):
    """
    Розбиваємо інфіксний вираз на список токенів (числа, оператори, дужки).
    """
    token_pattern = r'\d+\.\d+|\d+|[+*/^-()]'
    tokens = re.findall(token_pattern, expression)
    return tokens

def infix_to_suffix(expression):
    """
    Перетворює інфіксний вираз у суфіксний (постфіксний) запис.
    """
    # Крок 1: Отримання токенів
    tokens = tokenize(expression)
    
    # Крок 2: Ініціалізація стеку для операторів і вихідного списку
    operator_stack = []
    output = []
    
    # Визначення пріоритету операторів
    precedence = {
        '+': 1,
        '-': 1,
        '*': 2,
        '/': 2,
        '^': 3  # Піднесення до степеня. Зауважте, що ^ зазвичай є операцією з правою асоціативністю.
    }
    
    # Крок 3: Обхід токенів
    for token in tokens:
        # Якщо токен - операнд (число або змінна)
        if re.match(r'\d+(\.\d+)?', token):
            output.append(token)
        # Якщо токен - ліва дужка
        elif token == '(':
            operator_stack.append(token)
        # Якщо токен - права дужка
        elif token == ')':
            while operator_stack and operator_stack[-1] != '(':
                output.append(operator_stack.pop())
            if operator_stack:
                operator_stack.pop()  # Видаляємо відповідну ліву дужку
            else:
                raise ValueError("Невірне розташування дужок")
        # Якщо токен є оператором
        else:
            # Виштовхуємо оператори зі стеку, якщо вони мають вищий або рівний пріоритет
            while (operator_stack and operator_stack[-1] != '(' and 
                   precedence.get(operator_stack[-1], 0) >= precedence.get(token, 0)):
                output.append(operator_stack.pop())
            operator_stack.append(token)
    
    # Крок 4: Додаємо всі залишкові оператори до вихідного списку
    while operator_stack:
        if operator_stack[-1] in ('(', ')'):
            raise ValueError("Невірне розташування дужок")
        output.append(operator_stack.pop())
    
    return " ".join(output)

# Приклад використання
if __name__ == "__main__":
    infix_expr = "3 + 4 * (2 - 1)"
    suffix_expr = infix_to_suffix(infix_expr)
    print("Інфіксний вираз:", infix_expr)
    print("Суфіксний (постфіксний) вираз:", suffix_expr)

```