### Моделювання лабіринту
- можемо зобразити двома матрицями, де в одній - стіни й проходи, а в другій - відвідані й невідвідані, можливо одною.
- реалізація одною матрицею: лабіринт заданий двовимірним масивом, в якому -1 - стіна, 0 - ще не відвідана вершина, інше - відстань від старту до заданої. 
- для координат маємо два списки - один для напрямку по осі $Y$, інший по осі $X$. Координатні осі розташовані так: початок координат у верхньому лівому кутку.
  Якщо рух по діагоналям неможливий:
  $[1, -1, 0, 0]$
  $[0, 0, 1, -1]$
  Якщо рух по діагоналям можливий:
  $[1, 1, -1, -1, 0, 0, 0, 0]$
  $[0, 0, 0, 0, 1, 1, -1, -1]$

### Алгоритм пошуку найкоротшого шляху в лабіринті
- використовується варіація хвильового пошуку.
- стартова вершина задається парою або спеціальною структурою даних. 
- додаємо вершину в чергу.
- маємо матрицю для хвильового алгоритму і матрицю батьків, щоб відновити шлях.
- поки черга не порожня, беремо голову як поточну вершину (це фактично означає змістити "елемент", який і проходиться по лабіринту в потрібне місце) і викидаємо її, проходимося по всьому набору координат - суміщаючи відповідний індекс двох списків (4 або 8 разів).
- якщо ця клітинка не є стіною та не відвідана - додаємо в чергу, навпроти відповідного індексу в матриці до відстані поточного елемента додати 1.
- на відповідну позицію матриці батьків ставимо поточну вершину. 
- зауваження: ми прибираємо голову черги саме на початку циклу, тому що нам потрібно оголосити переміщення елемента. 
- постійно перевіряємо, чи не стала поточна вершина фінішом - якщо так, зупиняємо програму. 
- число у комірці фінішу матриці - і є найкоротша дистанція, а шлях ми можемо відновити закидуючи в стек пару, яка на наступній ітерації задасть місце наступного елементу. 