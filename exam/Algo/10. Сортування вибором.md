### Ідея алгоритму
полягає у тому, що на кожному кроці відбувається пошук найбільшого елементу серед невідсортованої частини списку, який переставляється на відповідну позицію (крайню праву/ліву позицію невідсортованої частини списку). Кожний наступний цикл відбувається з позиції 0 до $n - j$ або від $j$ до $n$ відповідно. 
- дуже подібний до бульбашкового сортування, проте є дещо оптимальнішим, оскільки за кожен прохід по списку відбувається лише одна операція перестановки елементів.
### Реалізація
```c++
#include <iostream>
#include <vector>
using namespace std;

void selectionsort(vector<int>& v)
{
    for (int i = 0; i < v.size(); i++)
    {
        int minIdx = i;
        for (int j = i + 1; j < v.size(); j++)
            if (v[j] < v[minIdx])
                minIdx = j;
        swap(v[i], v[minIdx]);
    }
}

int main()
{
    int n;
    cin >> n;
    vector<int> v;
    for (int i = 0; i < n; i++)
    {
        int x;
        cin >> x;
        v.push_back(x);
    }
    selectionsort(v);
    for (int i = 0; i < n; i++)
        cout << v[i] << " ";
    
}

```
### Аналіз алгоритму
хоча він і буде ефективнішним за бульбашкове, але все ж ми робимо $n - 1$ цикл, на кожному з яких буде здійснено $n - j$ операцій, тому асмиптотична складність лишається $O(n^2$). 