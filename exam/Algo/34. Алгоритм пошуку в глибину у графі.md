**Алгоритм пошуку в глибину**  — алгоритм для обходу графа, у якому застосовується стратегія йти, на скільки це можливо, вглиб графа. Проте на відміну від дерев пошук в глибину (власне як і пошук в ширину) має одну особливість – при обході дерев, на відміну від графів, не може трапитися ситуація при якій ми спробуємо відвідати вершину у якій ми вже були. Для цього ми можемо зберігати список вершин, де ми вже були, щоб не зайти туди повторно. 
- можна реалізувати рекурсивно або за допомогою стеку.

### Реалізація для списку суміжності
- ітеруємося тільки по сусідах вершини.
```c++
void dfs(int v, vector<int> &used)  
{  
    sense(v);  
    used[v] = 1;  
    for (int to : graph[v]) 
    {  
        if (used[to] == 0) 
        {  
            dfs(to, used);  
        }    
    }  
}
```

### Реалізація для матриці суміжності
- ітеруємося по всім, але робимо перевірку.
```c++
void dfs(int v, vector<int>& used)  
{  
  
    used[v] = 1;  
    sense(v);  
    for (int i = 0; i < size; i++)  
    {        
	    if (graph[v][i] == 1)  
        {            
	        if (used[i] == 0)  
            {                
	            used[i] = 1;  
                dfs(i, used);  
            }        
        }    
    }
}
```

### Асимптотична складність 
- для матриці суміжності - $O(n^2)$, де $n$ - кількість вершин, адже робимо перевірку для кожного вільного поля. 
- для списку суміжності - $O(n + m)$ - де n - кількість вершин, а m - кількість ребер, адже кожне ребро обробляється тільки один раз.
