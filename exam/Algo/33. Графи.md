### Основні відходи зображення графів
- матриця суміжності: маємо масив розміру $n * n$, де $n$ - порядок графа. Для незваженого орієнтованого графа для кожної вершини навпроти вершини, яка є її сусідом, буде стояти 1, якщо дана вершина втикається у сусіда, 0 - якщо ні. Для незваженого неорієнтованого, 1 буде і на тому місці, де в дану вершину втикається сусід. Для зважених аналогічним чином, але 1 заміняється на вагу графа. 
- список суміжності: маємо двовимірний масив, для кожної вершини записуємо індекси тих вершин, з ким вершина має ребро (або в які напрямлена, якщо це орієнтований граф). Для зваженого графа можна зберігати пару з номером вершини-сусіда і навантаженням.
- матрицю суміжності для графів рекомендується використовувати для задач, у яких кількість вершин є не значною (максимум 2к вершин), кількість вершин наперед відома та задача не передбачає додавання чи видалення вершин.
### Реалізація списку суміжності
```c++
#include <iostream>  
#include <vector>  
#include <algorithm>  
#include <queue>  
using namespace std;  
  
class ListGraph  
{  
private:  
  
    void sense(int v);  
    bool oriented;  
    int size;  
    vector<vector<int>> graph;  
  
public:  
    explicit ListGraph(int n, bool is_oriented = false)  
      : oriented(is_oriented), size(n), graph(n)  
    {}  
  
    void addEdge(int u, int v)  
    {        
	    graph[u].push_back(v);  
        if(oriented == false)  
        {            
	        graph[v].push_back(u);  
        }    
    }    
    void deleteEdge(int u, int v)  
    {        
	    graph[u].erase(remove(graph[u].begin(), graph[u].end(), v), graph[u].end());  
        if(oriented == false)  
        {            
        graph[v].erase(remove(graph[v].begin(), graph[v].end(), u), graph[v].end());  
        }    
    }  
    
};
```

### Реалізація матриці суміжності
```c++
#include <iostream>  
#include <vector>  
#include <algorithm>  
#include <queue>  
using namespace std;  
  
class Graph  
{  
private:  
    void sense(int v);  
    vector<vector<int>> graph;  
    int size;  
    bool oriented;  
public:  
    explicit Graph(int n, bool is_oriented = false)  
      : oriented(is_oriented), size(n), graph(n)  
    {}  
    void addEdge(int v, int w)  
    {        
	    graph[v][w] = 1;  
        if ( oriented == false)  
        {            
	        graph[w][v] = 1;  
        }    
    }    
    void deleteEdge(int v, int w)  
    {        
	    graph[v][w] = 0;  
        if ( oriented == false)  
        {            
	        graph[w][v] = 0;  
        }    
    }    
};
```

### Переваги та недоліки матриці суміжності
#### Переваги
- простота реалізації.
- математична наочність.
- однаково реалізується як зважений так і не зважений граф.
#### Недоліки
- проблематично додавати/видаляти вершини.
- великий об’єм оперативної пам’яті, що використовується даремно.
- для ідентифікації вершин (без додаткового виділення коду) можуть використовуватися лише послідовні натуральні числа.
- навантаження вершин треба реалізовувати окремою структурою даних.
- при побудові алгоритмів (наприклад пошуку в глибину чи ширину) пошук сусідів для кожної вершини є лінійним, оскільки вимушує пробігати повністю по відповідному рядку матриці.

### Переваги та недоліки списку суміжності
#### Переваги
- менший об'єм оперативної пам'яті.
- пошук є логарифмічним.
- легко видаляти і додавати вершини.
#### Недоліки 
- довго перевіряти, що є ребро - треба пройтися по всьому вектору для перевірки. 
- не наочно.
- складно реалізовувати.
- складніше перевіряти наявність ребра.

