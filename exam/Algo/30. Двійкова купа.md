**Двійкова (бінарна) купа** – це бінарне дерево, для якого виконуються такі умови:
-  будь-яке її (ліве чи праве) піддерево є
двійковою купою;
- значення ключа будь-якого вузла є не
більшим (або не меншим) за значення
ключів його дітей.
- глибина усіх листків дерева
відрізняється не більше ніж на 1.
- при додаванні нових вузлів, останній
шар заповнюється зліва направо (без
«дірок»).
- купа є майже повним бінарним деревом.
- для 0-базованої індекси дітей: $2*i + 1$, $2*i + 2$.
- для 0-базованої індекс батька - $\lfloor\frac{i - 1}{2}\rfloor$
- кількість вузлів для повного бінарного дерева - $2^{n + 1}- 1$.
- кількість вузлів для неповного: між $2^{n}$ і $2^{n + 1}- 1$.

### Базові операції (для мінімальної купи)
- створення купи.
- операція empty - чи порожня купа - $O(1)$.
- операція insert(key) - вставити елемент у купу - $O(log(n))$ (просіювання вгору).
- операція extract_minimum() - вилучити мінімальний елемент - $O(log(n))$ (просіювання вниз).
### Додаткові операції
- операція update(key, newkey) - замінити ключ key у купі новим значенням newkey $O(log(n))$ (якщо новий ключ менший за попередній - просіювання вгору, навпаки - вниз).
- операція get_minimum() - вивести мінімальний елемент - $O(1)$.  
### Реалізація
```c++
#include <iostream>  
#include <vector>  
using namespace std;  

bool empty(vector<int> &v)
{
	if (v.empty())
	{
		return true;
	}
	return false;
}
  
void insert(vector<int> &v, int value)  
{  
    v.push_back(value);  
    int i = v.size() - 1;  
    while(v[(i - 1)/2] > v[i])
	    {  
        swap(v[i], v[(i + 1)/2]);  
        i = (i - 1) / 2;  
        if (i == 0)  
        {            
	        return;  
        }  
    }
}
void extract_minimum(vector<int> &v)  
{  
    swap(v[0], v[v.size() - 1]);  
    v.pop_back();  
    int i = 0;  
    while (2*i + 1 < v.size() && (v[i] > v[2*i + 1] || (2*i + 2 < v.size() && v[i] > v[2*i + 2])))  
    {        
	    if (2*i + 2 >= v.size())  
        {            
	        swap(v[i], v[2*i + 1]);  
            i = 2*i + 1;    
        }        
        if (v[2*i + 1] < v[2*i + 2])  
        {            
	        swap(v[i], v[2*i + 1]);  
            i = 2*i + 1;  
        }        
        else  
        {  
            swap(v[i], v[2*i + 2]);  
            i = 2*i + 2;  
        }    
    }
}
```

### Застосування бінарної купи
- пріоритетна черга.
- щвидкий алгоритм сортування – пірамідальне сортування (англ. heapsort).