### Ідея алгоритму 
здійснюється кілька проходів по списку, під час кожного з яких порівнюють пари сусідніх елементів. Якщо елементи стоять не правильно, вони міняються місцями. Кожен прохід
по списку ставить наступне найбільше значення на його правильну позицію. (з кожним проходом ми не доходимо до кінця, адже найбільший елемент  опиниться в кінці).
### Аналіз 
незалежно від списку буде здійснено $n$ - 1 операцію, а з кожним наступним разом - $n - j$, таким чином бульбашкове сортування має складність стабільно $O(n^2)$.
### Реалізація

```c++
#include <iostream>
#include <vector>
using namespace std;

void bubblesort(vector<int>& v)
{
    int p = v.size();
    while (p > 0)
    {
        for (int j = 1; j < p; j++)
        {
            if (v[j] < v[j - 1])
            {
                swap(v[j], v[j - 1]);
            }
        }
        p--;
    }
}

int main()
{
    int n;
    cin >> n;
    vector<int> v;
    for (int i = 0; i < n; i++)
    {
        int x;
        cin >> x;
        v.push_back(x);
    }
    bubblesort(v);
    for (int i = 0; i < n; i++)
        cout << v[i] << " ";
    cout << endl;
    return 0;
}
```

### Оптимізація - сортування-шейкер
В чому полягає оптимізація і де відмінність?
- вводимо флагову змінну, де перевіряємо, чи відбулася хоча б одна перестановка. Якщо ні, перериваємо цикл - масив відсортований.
- тепер ми рухаємося у два напрямки - спочатку порівнюємо класичним чином, після чого йдемо "назад" і відштовхуємо маленькі елементи вперед.
-  сортуємо масив не з 0 до $n - j$ , а запам'ятовуємо, де відбулося перше й останнє сортування й сортуємо в цьому діапазоні
-  асимптотична складність - теж $O(n^2)$ в середньому і в найгіршому, але в даному випадку зазвичай швидше десь в 2-4 рази. Найкращий випадок - $O(n)$.

```#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

void shakerSort(vector<int>& a) {
    int left = 0, right = a.size() - 1;
    while (left < right) {
        int newRight = left;
        for (int i = left; i < right; ++i) {
            if (a[i] > a[i+1]) {
                swap(a[i], a[i+1]);
                newRight = i;
            }
        }
        right = newRight;
        int newLeft = right;
        for (int i = right; i > left; --i) {
            if (a[i] < a[i-1]) {
                swap(a[i], a[i-1]);
                newLeft = i;
            }
        }
        left = newLeft;
    }
}

int main() {
    int n;
    cin >> n;
    vector<int> v(n);
    for (int i = 0; i < n; ++i) {
        cin >> v[i];
    }
    shakerSort(v);
    for (int x : v) {
        cout << x << " ";
    }
    cout << "\n";
    return 0;
}

```