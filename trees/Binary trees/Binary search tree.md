## Бінарне дерево пошуку

Бінарне дерево називається **бінарним деревом пошуку**, якщо:
1) обидва його піддерева — і ліве, і праве — є бінарними деревами пошуку;
2) для будь-якого вузла *n*, значення ключів усіх вузлів лівого піддерева є меншими за значення ключа вузла *n*;
3) для будь-якого вузла *n*, значення ключів усіх вузлів правого піддерева є більшими за значення ключа вузла *n*.

---

### Приклад вхідних даних:
```
12, 19, 8, 4, 10, 5, 21, 11, 15, 9, 1, 14, 16
```

---

### Найменший елемент
Найменший елемент у бінарному дереві пошуку розташовується у листку, до якого можна дістатися послідовним переходом починаючи від кореня, переходячи кожного разу до лівого сина вузла.

### Найбільший елемент
Найбільший елемент у бінарному дереві пошуку розташовується у листку, до якого можна дістатися послідовним переходом починаючи від кореня, переходячи кожного разу до правого сина вузла.

---

## Основні операції з бінарним деревом пошуку:
1. Створення дерева пошуку.
2. Операція `empty()` — визначення, чи дерево порожнє.
3. Операція `search(key)` — пошук елемента у дереві за заданим ключем `key`.
4. Операція `insert(key)` — вставка елемента `key` у дерево.
5. Операція `delete(key)` — видалення елемента з ключем `key`, якщо такий елемент у дереві є.

Бінарні дерева пошуку дозволяють реалізувати абстрактний тип даних — асоціативний масив, подібно до хеш-таблиці.

Реалізація ґрунтується на рекурсивній структурі дерева. Опис методів буде охоплювати операції 3–5.

---

## Пошук у дереві

Дійсно, досить лише рухатися починаючи від кореня дерева у напрямку його листків, вибираючи у вузлах гілку, залежно від результату порівняння шуканого елементу з ключем `key` зі значенням ключа відповідного вузла:

- якщо шуканий ключ `key` більший за ключ вузла — вибираємо праву гілку;
- якщо шуканий ключ `key` менший за ключ вузла — вибираємо ліву гілку;
- якщо шуканий ключ `key` збігається з ключем вузла — елемент знайдено у дереві;
- якщо вузол є листком — дерево пошуку не містить шуканого елементу.
## Вставка у дереві

Операція вставки нового вузла з ключем `key` у дерево дуже подібна на операцію пошуку – фактично вона полягає у пошуку місця для вставки нового листка у дерево. Її алгоритм полягає у такому:
- якщо бінарне дерево пошуку порожнє — коренем дерева встановлюємо новий вузол з ключем `key`;
- якщо дерево не порожнє, спускаємося по дереву від кореня відповідно до вищенаведеного алгоритму пошуку;
- якщо дерево містить ключ `key`, припиняємо роботу алгоритму — вставка не потрібна;
- якщо дерево не містить ключа `key`, тобто ми досягли вузла, що не має відповідного сина — додаємо новий вузол з ключем `key` як відповідного сина дерева.

---

## Видалення у дереві

Нарешті розглянемо алгоритм операції видалення. Алгоритмічно вона є найскладнішою серед набору базових операцій. Розглянемо її детальніше.

Видалення елемента з ключем `key` прочитується з пошуку відповідного вузла у дереві.

- якщо бінарне дерево пошуку порожнє або такого елементу у дереві не знайдено, то операція, у найпростішому випадку, породжує виключення;
- якщо відповідний вузол знайдений, аналізуємо наявність у нього дітей:
  1. якщо вузол не має дітей — видаляємо його без будь-яких наслідків;
  2. якщо вузол має лише одного сина (лівого або правого) — заміняємо вузол, що видаляється, сином;
  3. якщо вузол має обох синів — знаходимо у лівому піддереві вузол з максимальним ключем, переставляємо цей вузол на місце елемента, що видаляється (ця операція передбачає відповідно рекурсивну операцію видалення знайденого вузла з максимальним ключем у лівому піддереві).

