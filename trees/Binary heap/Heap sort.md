## Пірамідальне сортування (Heap Sort)

Алгоритм пірамідального сортування складається з двох основних кроків:

1. **Відновлення структури двійкової купи** для вхідного масиву даних (проходимся просіюванням вниз для всіх не листків знизу вверх).
   - Побудова максимальної купи (max-heap), де кожен батьківський елемент більший або рівний своїм дітям.
   - Цей етап гарантує, що найбільший елемент буде на вершині купи (тобто на початку масиву).

2. **Виштовхування найбільших елементів у кінець масиву**:
   - Обмін найбільшого елемента (кореня купи) з останнім елементом масиву.
   - Зменшення розміру купи.
   - Відновлення властивостей купи (heapify) для зменшеного масиву.
   - Повторення до тих пір, поки масив не буде відсортовано.

Алгоритм працює на місці (in-place) і має складність **O(n log n)**.

---

Цей алгоритм базується на структурі **двійкової купи** та ідеї повного бінарного дерева.


```python
def heapSort(array):
	""" Пірамідальне сортування вхідного масиву
	:param array: вхідний масив даних """
	
	size = len(array)
	# Відновлення структури двійкової купи для вхідного масиву даних
	# Для всіх внутрішніх вузлів дерева двійкової купи
	# (для вузлів з індексами [0, size / 2] )
	for i in range(size // 2 - 1, -1, -1):
		siftDown(array, i, size) # здійснюємо просіювання вниз
		# Для всіх внутрішніх вузлів дерева двійкової купи
	for i in range(size - 1, 0, -1):
		# Представляємо найбільший елемент у кінець
		array[0], array[i] = array[i], array[0]
		# тепер частина масиву з індексами [i, size - 1] відсортована
		# Відновлюємо структуру двійкової купи для частини масиву [0, i - 1]
		siftDown(array, 0, i) # просіюванням елементу з індексом 0 вниз

def siftDown(array, start, end):
	""" Функція просіювання елементів двійкової купи вниз
	Здійснює просіювання елементів двійкової купи у діапазоні [start, end - 1] так,
	що найбільший елемент найбільший елемент опиняється у позиції start
	:param array: Вхідний масив, що моделює двійкову купу
	:param end: Розмір двійкової купи
	:param start: Початковий індекс """
	
	while True:
		# Визначаємо лівого та правого синів поточного вузла
		# Індекси масиву починаються від нуля, тому
		left = start * 2 + 1
		right = left + 1
		
		largest = start
		if left < end and array[left] > array[largest]:
			largest = left
		if right < end and array[right] > array[largest]:
			largest = right
		if largest == start:
			break
	
		array[start], array[largest] = array[largest], array[start]
		start = largest
```