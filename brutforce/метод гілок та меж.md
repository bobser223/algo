
### Ідея
Метод гілок і меж базується на двох процедурах – розгалуженні та знаходженні оцінок
(меж).

Процедура розгалуження полягає у тому, що множина допустимих розв’язків
розбивається на підмножини меншого розміру.

На кожному кроці елементи такого розбиття аналізуються на предмет того, чи містить
дана підмножина оптимальний розв’язок чи ні.

Якщо розглядається задача знаходження мінімуму цільової функції, то така перевірка
здійснюється шляхом обчислення оцінки знизу для цільової функції на даній
підмножині.

Якщо оцінка знизу не менша за рекорд (найкращий, зі знайдених розв’язків), то
підмножина може бути відкинута, оскільки вона не містить розв’язку, що кращий за
рекорд.

Якщо значення цільової функції на знайденому розв’язку є меншим за рекорд, то
відбувається зміна рекорду.


### Задача

Василько просто у захваті від гри "Вормікс". Він досягнув вже значного рівня, тож може відкривати бій із босом. Щоб відкрити новий бій, йому потрібно набрати не менше, ніж K очок за місії. Відомо, що всього є N місій. Для кожної місії відомо скільки часу триватиме її проходження і скільки за неї буде нараховано очок. Також відомо, що Василько є дуже добрим гравцем, а отже він з легкістю зможе пройти будь-яку місію. На жаль, він немає часу, щоб пройти всі місії, але дуже хоче відкрити бій з босом, тож він хоче дізнатися за який мінімальний проміжок часу він зможе набрати не менше K очок.

### Ідея розвязку
Як і у [[Real task|задачі про рюкзак]], система станів задачі є дискретною, а отже її можна розв’язати
повністю перебравши всі можливі розв’язки.

Як і у випадку задачі про рюкзак, у цій задачі кожна місія може бути врахована або не
врахована.

Оптимізуємо цю задачу скориставшись методом гілок та меж:
Будемо враховувати кожну наступну місію, лише у тому разі, якщо сумарний час усіх
попередніх місій разом з поточною не перевищує мінімального значення часу на деякому
розв’язку (рекорду).


### Implementation

```python
minTime = 100500 # ініціалізація значення рекорду

def findMinTime(time, score, mission_num):
	"""
	:param time: поточне значення часу
	:param score: поточний рахунок
	:param mission_num: номер місії """
	
	global minTime # поточний рекорд
	
	global t # масив, що містить час проходження кожної місії
	
	global a # масив, що містить рахунок проходження кожної місії
	
	# Термінальна гілка, якщо опрацьовані всі місії
	if mission_num >= N:
	# Якщо значення цільової функції на знайденому розв’язку є меншим за рекорд
		if score >= K and minTime > time:
			minTime = time # зміна рекорду
	return
	
	# рекурсивний виклик без урахуванням місії mission_num
	findMinTime(time, score, mission_num + 1)
	nextTime = time + t[mission_num]
	# Якщо оцінка знизу не менша за рекорд, то підмножина може бути відкинута
	if nextTime >= minTime:
		return
	
	nextScore = score + a[mission_num] # рахунок з урахування місії mission_num
	
	# рекурсивний виклик з урахуванням місії mission_num
	findMinTime(nextTime, nextScore, mission_num + 1)



maxN = 100
a = [0] * maxN
t = [0] * maxN

# зчитування даних задачі
N, K = map(int, input().split())

# зчитування вартостей місій та часу їхнього проходження

for i in range(N):
	a[i], t[i] = map(int, input().split())

findMinTime(0, 0, 0) # старт рекурсивної функції

# Виведення результату
if minTime == 100500:
	print(-1)
else:
	print(minTime)
```




